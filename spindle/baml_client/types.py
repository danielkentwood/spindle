# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

import typing
import typing_extensions
from enum import Enum


from pydantic import BaseModel, ConfigDict


import baml_py

CheckT = typing_extensions.TypeVar('CheckT')
CheckName = typing_extensions.TypeVar('CheckName', bound=str)

class Check(BaseModel):
    name: str
    expression: str
    status: str
class Checked(BaseModel, typing.Generic[CheckT, CheckName]):
    value: CheckT
    checks: typing.Dict[CheckName, Check]

def get_checks(checks: typing.Dict[CheckName, Check]) -> typing.List[Check]:
    return list(checks.values())

def all_succeeded(checks: typing.Dict[CheckName, Check]) -> bool:
    return all(check.status == "succeeded" for check in get_checks(checks))
# #########################################################################
# Generated enums (1)
# #########################################################################

class ProcessStepType(str, Enum):
    ACTIVITY = "ACTIVITY"
    DECISION = "DECISION"
    EVENT = "EVENT"
    PARALLEL_GATEWAY = "PARALLEL_GATEWAY"
    SUBPROCESS = "SUBPROCESS"

# #########################################################################
# Generated classes (33)
# #########################################################################

class AttributeDefinition(BaseModel):
    name: str
    type: str
    description: str

class AttributeValue(BaseModel):
    value: typing.Optional[str] = None
    type: str

class CharacterSpan(BaseModel):
    text: str
    start: typing.Optional[int] = None
    end: typing.Optional[int] = None

class EdgeForMatching(BaseModel):
    id: str
    subject: str
    predicate: str
    object: str
    evidence_summary: str

class EdgeMatch(BaseModel):
    edge1_id: str
    edge2_id: str
    is_duplicate: bool
    confidence_level: str
    reasoning: str

class EdgeMatchingResult(BaseModel):
    matches: typing.List["EdgeMatch"]
    reasoning: str

class Entity(BaseModel):
    name: str
    type: str
    description: str
    custom_atts: typing.Dict[str, "AttributeValue"]

class EntityForMatching(BaseModel):
    id: str
    type: str
    description: str
    attributes: str

class EntityMatch(BaseModel):
    entity1_id: str
    entity2_id: str
    is_duplicate: bool
    confidence_level: str
    reasoning: str

class EntityMatchingResult(BaseModel):
    matches: typing.List["EntityMatch"]
    reasoning: str

class EntityType(BaseModel):
    name: str
    description: str
    attributes: typing.List["AttributeDefinition"]

class EvidenceSpan(BaseModel):
    text: str
    start: typing.Optional[int] = None
    end: typing.Optional[int] = None

class ExtractionResult(BaseModel):
    triples: typing.List["Triple"]
    reasoning: str

class MetadataElement(BaseModel):
    element_id: str
    name: str
    element_type: str
    description: str
    data_type: str
    required: bool
    examples: typing.List[str]

class MetadataExtractionResult(BaseModel):
    elements: typing.List["MetadataElement"]
    reasoning: str

class Ontology(BaseModel):
    entity_types: typing.List["EntityType"]
    relation_types: typing.List["RelationType"]

class OntologyEnhancementResult(BaseModel):
    entity_types: typing.List["EntityType"]
    relation_types: typing.List["RelationType"]
    reasoning: str

class OntologyExtension(BaseModel):
    needs_extension: bool
    new_entity_types: typing.List["EntityType"]
    new_relation_types: typing.List["RelationType"]
    critical_information_at_risk: typing.Optional[str] = None
    reasoning: str

class OntologyRecommendation(BaseModel):
    ontology: "Ontology"
    text_purpose: str
    reasoning: str

class ProcessDependency(BaseModel):
    from_step: str
    to_step: str
    relation: str
    condition: typing.Optional[str] = None
    evidence: typing.List["EvidenceSpan"]

class ProcessExtractionIssue(BaseModel):
    code: str
    message: str
    related_step_ids: typing.List[str]

class ProcessExtractionResult(BaseModel):
    status: typing.Union[typing_extensions.Literal['process_found'], typing_extensions.Literal['no_process'], typing_extensions.Literal['incomplete']]
    graph: typing.Optional["ProcessGraph"] = None
    reasoning: str
    issues: typing.List["ProcessExtractionIssue"]

class ProcessGraph(BaseModel):
    process_name: typing.Optional[str] = None
    scope: typing.Optional[str] = None
    primary_goal: str
    start_step_ids: typing.List[str]
    end_step_ids: typing.List[str]
    steps: typing.List["ProcessStep"]
    dependencies: typing.List["ProcessDependency"]
    notes: typing.List[str]

class ProcessStep(BaseModel):
    step_id: str
    title: str
    summary: str
    step_type: ProcessStepType
    actors: typing.List[str]
    inputs: typing.List[str]
    outputs: typing.List[str]
    duration: typing.Optional[str] = None
    prerequisites: typing.List[str]
    evidence: typing.List["EvidenceSpan"]

class RelationType(BaseModel):
    name: str
    description: str
    domain: str
    range: str

class SourceMetadata(BaseModel):
    source_name: str
    source_url: typing.Optional[str] = None

class TaxonomyExtractionResult(BaseModel):
    relations: typing.List["TaxonomyRelation"]
    root_terms: typing.List[str]
    reasoning: str

class TaxonomyRelation(BaseModel):
    parent_term: str
    child_term: str
    relation_type: str
    confidence: str

class ThesaurusEntry(BaseModel):
    entry_id: str
    term_id: str
    preferred_label: str
    use_for: typing.List[str]
    broader_terms: typing.List[str]
    narrower_terms: typing.List[str]
    related_terms: typing.List[str]
    scope_note: typing.Optional[str] = None

class ThesaurusExtractionResult(BaseModel):
    entries: typing.List["ThesaurusEntry"]
    reasoning: str

class Triple(BaseModel):
    subject: "Entity"
    predicate: str
    object: "Entity"
    source: "SourceMetadata"
    supporting_spans: typing.List["CharacterSpan"]
    extraction_datetime: typing.Optional[str] = None

class VocabularyExtractionResult(BaseModel):
    terms: typing.List["VocabularyTerm"]
    domain_summary: str
    reasoning: str

class VocabularyTerm(BaseModel):
    term_id: str
    preferred_label: str
    definition: str
    synonyms: typing.List[str]
    domain: typing.Optional[str] = None

# #########################################################################
# Generated type aliases (0)
# #########################################################################
