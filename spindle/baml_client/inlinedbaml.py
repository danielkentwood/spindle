# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

_file_map = {

    "clients.baml": "// Learn more about clients at https://docs.boundaryml.com/docs/snippets/clients/overview\r\n\r\n// Using the new OpenAI Responses API for enhanced formatting\r\nclient<llm> CustomGPT5 {\r\n  provider openai-responses\r\n  options {\r\n    model \"gpt-5\"\r\n    api_key env.OPENAI_API_KEY\r\n  }\r\n}\r\n\r\nclient<llm> CustomGPT5Mini {\r\n  provider openai-responses\r\n  retry_policy Exponential\r\n  options {\r\n    model \"gpt-5-mini\"\r\n    api_key env.OPENAI_API_KEY\r\n  }\r\n}\r\n\r\n// Openai with chat completion\r\nclient<llm> CustomGPT5Chat {\r\n  provider openai\r\n  options {\r\n    model \"gpt-5\"\r\n    api_key env.OPENAI_API_KEY\r\n  }\r\n}\r\n\r\n// Latest Anthropic Claude 4 models\r\nclient<llm> CustomOpus4 {\r\n  provider anthropic\r\n  options {\r\n    model \"claude-opus-4-1-20250805\"\r\n    api_key env.ANTHROPIC_API_KEY\r\n  }\r\n}\r\n\r\nclient<llm> CustomSonnet4 {\r\n  provider anthropic\r\n  options {\r\n    model \"claude-sonnet-4-20250514\"\r\n    api_key env.ANTHROPIC_API_KEY\r\n  }\r\n}\r\n\r\nclient<llm> CustomHaiku {\r\n  provider anthropic\r\n  retry_policy Constant\r\n  options {\r\n    model \"claude-3-5-haiku-20241022\"\r\n    api_key env.ANTHROPIC_API_KEY\r\n  }\r\n}\r\n\r\n// Example Google AI client (uncomment to use)\r\n// client<llm> CustomGemini {\r\n//   provider google-ai\r\n//   options {\r\n//     model \"gemini-2.5-pro\"\r\n//     api_key env.GOOGLE_API_KEY\r\n//   }\r\n// }\r\n\r\n// Example AWS Bedrock client (uncomment to use)\r\n// client<llm> CustomBedrock {\r\n//   provider aws-bedrock\r\n//   options {\r\n//     model \"anthropic.claude-sonnet-4-20250514-v1:0\"\r\n//     region \"us-east-1\"\r\n//     // AWS credentials are auto-detected from env vars\r\n//   }\r\n// }\r\n\r\n// Example Azure OpenAI client (uncomment to use)\r\n// client<llm> CustomAzure {\r\n//   provider azure-openai\r\n//   options {\r\n//     model \"gpt-5\"\r\n//     api_key env.AZURE_OPENAI_API_KEY\r\n//     base_url \"https://MY_RESOURCE_NAME.openai.azure.com/openai/deployments/MY_DEPLOYMENT_ID\"\r\n//     api_version \"2024-10-01-preview\"\r\n//   }\r\n// }\r\n\r\n// Vertex AI client for Gemini models\r\nclient<llm> CustomGemini {\r\n  provider vertex-ai\r\n  options {\r\n    model \"gemini-2.0-flash-exp\"\r\n    location env.GCP_REGION\r\n    // Uses Google Cloud Application Default Credentials\r\n    // Set GCP_PROJECT_ID and GCP_REGION in your environment\r\n  }\r\n}\r\n\r\n// Vertex AI client for Anthropic models via Vertex\r\n// Notes: BAML may not have native vertex-anthropic provider\r\n// This uses openai-generic provider to connect to Vertex AI endpoint\r\nclient<llm> VertexSonnet4 {\r\n  provider openai-generic\r\n  options {\r\n    base_url env.VERTEX_ANTHROPIC_BASE_URL\r\n    model \"claude-sonnet-4-20250514\"\r\n    api_key env.VERTEX_ACCESS_TOKEN\r\n  }\r\n}\r\n\r\nclient<llm> VertexOpus4 {\r\n  provider openai-generic\r\n  options {\r\n    base_url env.VERTEX_ANTHROPIC_BASE_URL\r\n    model \"claude-opus-4-20250514\"\r\n    api_key env.VERTEX_ACCESS_TOKEN\r\n  }\r\n}\r\n\r\nclient<llm> VertexHaiku {\r\n  provider openai-generic\r\n  options {\r\n    base_url env.VERTEX_ANTHROPIC_BASE_URL\r\n    model \"claude-3-5-haiku-20241022\"\r\n    api_key env.VERTEX_ACCESS_TOKEN\r\n  }\r\n}\r\n\r\n// Example Ollama client for local models (uncomment to use)\r\n// client<llm> CustomOllama {\r\n//   provider openai-generic\r\n//   options {\r\n//     base_url \"http://localhost:11434/v1\"\r\n//     model \"llama4\"\r\n//     default_role \"user\" // Most local models prefer the user role\r\n//     // No API key needed for local Ollama\r\n//   }\r\n// }\r\n\r\n// https://docs.boundaryml.com/docs/snippets/clients/round-robin\r\nclient<llm> CustomFast {\r\n  provider round-robin\r\n  options {\r\n    // This will alternate between the two clients\r\n    strategy [CustomGPT5Mini, CustomHaiku]\r\n  }\r\n}\r\n\r\n// https://docs.boundaryml.com/docs/snippets/clients/fallback\r\nclient<llm> OpenaiFallback {\r\n  provider fallback\r\n  options {\r\n    // This will try the clients in order until one succeeds\r\n    strategy [CustomGPT5Mini, CustomGPT5]\r\n  }\r\n}\r\n\r\n// https://docs.boundaryml.com/docs/snippets/clients/retry\r\nretry_policy Constant {\r\n  max_retries 3\r\n  strategy {\r\n    type constant_delay\r\n    delay_ms 200\r\n  }\r\n}\r\n\r\nretry_policy Exponential {\r\n  max_retries 2\r\n  strategy {\r\n    type exponential_backoff\r\n    delay_ms 300\r\n    multiplier 1.5\r\n    max_delay_ms 10000\r\n  }\r\n}",
    "entity_resolution.baml": "// Entity Resolution: Semantic matching for knowledge graph deduplication\r\n// This file defines functions for identifying duplicate entities and edges using LLM-based matching\r\n\r\n// Represents a matched pair of entities\r\nclass EntityMatch {\r\n  entity1_id string @description(\"The unique identifier (name) of the first entity\")\r\n  entity2_id string @description(\"The unique identifier (name) of the second entity\")\r\n  is_duplicate bool @description(\"Whether these two entities represent the same real-world entity\")\r\n  confidence_level string @description(\"Confidence in the match decision: 'high', 'medium', or 'low'\")\r\n  reasoning string @description(\"Detailed explanation of why these entities are or aren't duplicates, considering name variations, types, descriptions, and attributes\")\r\n}\r\n\r\n// Represents a matched pair of edges (relationships)\r\nclass EdgeMatch {\r\n  edge1_id string @description(\"Identifier for first edge in format 'subject|predicate|object'\")\r\n  edge2_id string @description(\"Identifier for second edge in format 'subject|predicate|object'\")\r\n  is_duplicate bool @description(\"Whether these edges represent the same relationship\")\r\n  confidence_level string @description(\"Confidence in the match decision: 'high', 'medium', or 'low'\")\r\n  reasoning string @description(\"Detailed explanation considering subject/object similarity, predicate equivalence, and evidence overlap\")\r\n}\r\n\r\n// Simple entity representation for matching\r\nclass EntityForMatching {\r\n  id string @description(\"Entity unique identifier (name)\")\r\n  type string @description(\"Entity type from ontology\")\r\n  description string @description(\"Brief description of the entity\")\r\n  attributes string @description(\"JSON string of entity attributes\")\r\n}\r\n\r\n// Simple edge representation for matching\r\nclass EdgeForMatching {\r\n  id string @description(\"Edge identifier in format 'subject|predicate|object'\")\r\n  subject string @description(\"Subject entity name\")\r\n  predicate string @description(\"Relationship type\")\r\n  object string @description(\"Object entity name\")\r\n  evidence_summary string @description(\"Summary of supporting evidence\")\r\n}\r\n\r\n// Result of entity matching for a block\r\nclass EntityMatchingResult {\r\n  matches EntityMatch[] @description(\"List of identified duplicate pairs within this block\")\r\n  reasoning string @description(\"Overall reasoning about the matching process and decisions made\")\r\n}\r\n\r\n// Result of edge matching for a block\r\nclass EdgeMatchingResult {\r\n  matches EdgeMatch[] @description(\"List of identified duplicate edge pairs within this block\")\r\n  reasoning string @description(\"Overall reasoning about the matching process and decisions made\")\r\n}\r\n\r\n// Main function to match entities within a block\r\nfunction MatchEntities(\r\n  entities: EntityForMatching[],\r\n  context: string\r\n) -> EntityMatchingResult {\r\n  client CustomSonnet4\r\n  prompt #\"\r\n    You are an expert in entity resolution for knowledge graphs. Your task is to identify duplicate entities within a group of semantically similar entities.\r\n\r\n    {{ _.role(\"user\") }}\r\n    \r\n    **Context about this knowledge graph:**\r\n    {{ context if context else \"General domain knowledge graph\" }}\r\n\r\n    **Entities to analyze:**\r\n    {% for entity in entities %}\r\n    ---\r\n    ID: {{ entity.id }}\r\n    Type: {{ entity.type }}\r\n    Description: {{ entity.description }}\r\n    Attributes: {{ entity.attributes }}\r\n    {% endfor %}\r\n    ---\r\n\r\n    **Task:** \r\n    Identify which entities in this group are duplicates of each other. Consider:\r\n    \r\n    1. **Name variations**: \"TechCorp\", \"Tech Corp\", \"TechCorp Inc.\" likely refer to the same entity\r\n    2. **Semantic similarity**: \"NYC\" and \"New York City\" are the same\r\n    3. **Type consistency**: Entities must have compatible types to be duplicates\r\n    4. **Attribute alignment**: Similar or complementary attributes strengthen a match\r\n    5. **Description consistency**: Descriptions should be compatible, not contradictory\r\n    \r\n    **Guidelines:**\r\n    - Only mark entities as duplicates if you're confident they refer to the same real-world entity\r\n    - Use \"high\" confidence for clear matches (obvious name variations, identical descriptions)\r\n    - Use \"medium\" confidence for probable matches (semantic similarity, consistent attributes)\r\n    - Use \"low\" confidence for possible matches (weak signals, some inconsistency)\r\n    - Avoid false positives - when in doubt, mark is_duplicate as false\r\n    - Provide clear reasoning for each match decision\r\n    - Check for transitive consistency: if A matches B and B matches C, A should match C\r\n\r\n    {{ ctx.output_format }}\r\n  \"#\r\n}\r\n\r\n// Main function to match edges within a block\r\nfunction MatchEdges(\r\n  edges: EdgeForMatching[],\r\n  context: string\r\n) -> EdgeMatchingResult {\r\n  client CustomSonnet4\r\n  prompt #\"\r\n    You are an expert in entity resolution for knowledge graphs. Your task is to identify duplicate edges (relationships) within a group of semantically similar edges.\r\n\r\n    {{ _.role(\"user\") }}\r\n    \r\n    **Context about this knowledge graph:**\r\n    {{ context if context else \"General domain knowledge graph\" }}\r\n\r\n    **Edges to analyze:**\r\n    {% for edge in edges %}\r\n    ---\r\n    ID: {{ edge.id }}\r\n    Triple: {{ edge.subject }} -[{{ edge.predicate }}]-> {{ edge.object }}\r\n    Evidence: {{ edge.evidence_summary }}\r\n    {% endfor %}\r\n    ---\r\n\r\n    **Task:**\r\n    Identify which edges in this group are duplicates of each other. Consider:\r\n    \r\n    1. **Entity equivalence**: Subject and object entities should be the same or known duplicates\r\n    2. **Predicate equivalence**: Predicates should express the same relationship (e.g., \"works_at\" vs \"employed_by\")\r\n    3. **Evidence overlap**: Duplicates often cite the same or overlapping source text\r\n    4. **Direction consistency**: Ensure relationship direction is the same\r\n    5. **Temporal consistency**: Check if edges describe the same timeframe\r\n    \r\n    **Guidelines:**\r\n    - Only mark edges as duplicates if they represent the same relationship between the same entities\r\n    - Use \"high\" confidence for edges with identical subjects, predicates, objects\r\n    - Use \"medium\" confidence for edges with equivalent predicates and matching entities\r\n    - Use \"low\" confidence for edges with similar but not identical structure\r\n    - Edges with contradictory information (different dates, different evidence) are NOT duplicates\r\n    - Provide clear reasoning for each match decision\r\n    - Consider that edges from different sources can still be duplicates if they express the same fact\r\n\r\n    {{ ctx.output_format }}\r\n  \"#\r\n}\r\n\r\n",
    "generators.baml": "// This helps use auto generate libraries you can use in the language of\r\n// your choice. You can have multiple generators if you use multiple languages.\r\n// Just ensure that the output_dir is different for each generator.\r\ngenerator target {\r\n    // Valid values: \"python/pydantic\", \"typescript\", \"ruby/sorbet\", \"rest/openapi\"\r\n    output_type \"python/pydantic\"\r\n\r\n    // Where the generated code will be saved (relative to baml_src/)\r\n    // BAML creates a baml_client/ subdir inside this path, so we use \"..\"\r\n    // to generate directly into spindle/baml_client/\r\n    output_dir \"..\"\r\n\r\n    // The version of the BAML package you have installed (e.g. same version as your baml-py or @boundaryml/baml).\r\n    // The BAML VSCode extension version should also match this version.\r\n    version \"0.213.0\"\r\n\r\n    // Valid values: \"sync\", \"async\"\r\n    // This controls what `b.FunctionName()` will be (sync or async).\r\n    default_client_mode sync\r\n}\r\n",
    "process.baml": "// Process DAG Extraction Schemas and Function\r\n\r\nenum ProcessStepType {\r\n  ACTIVITY @description(\"Linear action that advances the process\")\r\n  DECISION @description(\"Branching evaluation that selects one of multiple paths\")\r\n  EVENT @description(\"External trigger or milestone that influences the process\")\r\n  PARALLEL_GATEWAY @description(\"Point where multiple activities run concurrently\")\r\n  SUBPROCESS @description(\"Reference to a nested process or reusable routine\")\r\n}\r\n\r\nclass EvidenceSpan {\r\n  text string @description(\"Exact excerpt from the source that supports the step or dependency\")\r\n  start int? @description(\"Zero-based start index of the span within the text\")\r\n  end int? @description(\"End index (exclusive) of the span within the text\")\r\n}\r\n\r\nclass ProcessStep {\r\n  step_id string @description(\"Stable identifier used for references and dependencies\")\r\n  title string @description(\"Short human-readable name for the step\")\r\n  summary string @description(\"Concise explanation of what happens during this step\")\r\n  step_type ProcessStepType @description(\"Category that characterises the behaviour of the step\")\r\n  actors string[] @description(\"People, roles, or systems responsible for executing the step\")\r\n  inputs string[] @description(\"Key inputs, prerequisites, or artifacts consumed by this step\")\r\n  outputs string[] @description(\"Artifacts, decisions, or state transitions produced by this step\")\r\n  duration string? @description(\"Estimated timing or duration information if mentioned\")\r\n  prerequisites string[] @description(\"Step identifiers that must be completed before this step starts\")\r\n  evidence EvidenceSpan[] @description(\"Supporting text spans drawn from the source material\")\r\n}\r\n\r\nclass ProcessDependency {\r\n  from_step string @description(\"Identifier of the antecedent step\")\r\n  to_step string @description(\"Identifier of the dependent step\")\r\n  relation string @description(\"Nature of the dependency, e.g., 'precedes', 'blocks', 'enables'\")\r\n  condition string? @description(\"Conditional logic or guard that must be satisfied for the dependency\")\r\n  evidence EvidenceSpan[] @description(\"Supporting spans demonstrating this dependency in the text\")\r\n}\r\n\r\nclass ProcessGraph {\r\n  process_name string? @description(\"Human-readable name or title for the overall process\")\r\n  scope string? @description(\"Short description of the process boundaries or context\")\r\n  primary_goal string @description(\"Statement summarising the overall objective of the process\")\r\n  start_step_ids string[] @description(\"Identifiers of steps that have no incoming dependencies\")\r\n  end_step_ids string[] @description(\"Identifiers of steps that have no outgoing dependencies\")\r\n  steps ProcessStep[] @description(\"All steps that participate in the process\")\r\n  dependencies ProcessDependency[] @description(\"Directed edges connecting steps to form a DAG\")\r\n  notes string[] @description(\"Additional remarks, open questions, or caveats captured by the model\")\r\n}\r\n\r\nclass ProcessExtractionIssue {\r\n  code string @description(\"Machine-friendly identifier describing the issue\")\r\n  message string @description(\"Human-readable explanation of the issue or warning\")\r\n  related_step_ids string[] @description(\"Step identifiers relevant to this issue\")\r\n}\r\n\r\nclass ProcessExtractionResult {\r\n  status \"process_found\" | \"no_process\" | \"incomplete\" @description(\"Outcome of the extraction attempt\")\r\n  graph ProcessGraph? @description(\"Structured representation of the process when available\")\r\n  reasoning string @description(\"Narrative justification covering modelling choices and DAG structure\")\r\n  issues ProcessExtractionIssue[] @description(\"Non-fatal problems encountered during extraction\")\r\n}\r\n\r\nfunction ExtractProcessGraph(\r\n  text: string,\r\n  process_hint: string?,\r\n  existing_graph: ProcessGraph?\r\n) -> ProcessExtractionResult {\r\n  client CustomFast\r\n  prompt #\"\r\n    You are a process modelling specialist. Extract a directed acyclic graph (DAG) that captures the end-to-end process described in the provided text. Represent the process with well-defined steps and explicit dependencies.\r\n\r\n    {{ _.role(\"user\") }}\r\n\r\n    TEXT:\r\n    {{ text }}\r\n\r\n    {% if process_hint %}\r\n    PROCESS HINT:\r\n    {{ process_hint }}\r\n    {% endif %}\r\n\r\n    {% if existing_graph %}\r\n    EXISTING GRAPH CONTEXT:\r\n    - Process name: {{ existing_graph.process_name or \"Unknown\" }}\r\n    - Steps already known: {{ existing_graph.steps | map(attribute='step_id') | list }}\r\n    When possible, reuse step identifiers from the existing graph to maintain continuity.\r\n    {% endif %}\r\n\r\n    OUTPUT REQUIREMENTS:\r\n    1. Return status \"no_process\" if the text lacks procedural content.\r\n    2. Always ensure dependency targets reference defined step identifiers.\r\n    3. Identify start and end steps explicitly using computed arrays.\r\n    4. Capture conditional flows, loops described as repeated checks, and parallel work using step types and dependency relation labels.\r\n    5. Provide issues for ambiguous, conflicting, or incomplete information rather than guessing.\r\n    6. Summarise reasoning with numbered bullet points that justify the chosen structure and highlight any assumptions.\r\n\r\n    {{ ctx.output_format }}\r\n  \"#\r\n}\r\n\r\n",
    "spindle.baml": "// Spindle: Knowledge Graph Triple Extraction\r\n// This file defines the data structures and extraction function for building knowledge graphs from text\r\n\r\n// Source metadata for tracking where a triple came from\r\nclass SourceMetadata {\r\n  source_name string @description(\"The name or identifier of the source document\")\r\n  source_url string? @description(\"Optional URL of the source document\")\r\n}\r\n\r\n// Character span indicating text evidence for a triple\r\nclass CharacterSpan {\r\n  text string @description(\"The exact text from the source that supports this triple\")\r\n  start int? @description(\"Starting character index in the source text (0-based, computed in post-processing)\")\r\n  end int? @description(\"Ending character index in the source text (exclusive, computed in post-processing)\")\r\n}\r\n\r\n// Attribute definition for entity types in the ontology\r\nclass AttributeDefinition {\r\n  name string @description(\"The name of the attribute (e.g., 'campaign_launch_dt', 'founded_date')\")\r\n  type string @description(\"Data type: 'string', 'int', 'float', 'bool', 'date', or a nested object schema definition\")\r\n  description string @description(\"A description of what this attribute represents\")\r\n}\r\n\r\n// Attribute value in extracted entities (includes type metadata)\r\nclass AttributeValue {\r\n  value string? @description(\"The extracted value as a string, or null if not found in the text\")\r\n  type string @description(\"The data type of this attribute (matches the type from AttributeDefinition)\")\r\n}\r\n\r\n// Structured entity in a triple\r\nclass Entity {\r\n  name string @description(\"The entity's name or identifier extracted from the text\")\r\n  type string @description(\"The entity type from the ontology (must match an EntityType.name exactly)\")\r\n  description string @description(\"A brief description of the entity generated from the text context\")\r\n  custom_atts map<string, AttributeValue> @description(\"Type-specific attributes as defined in the entity type's AttributeDefinition list\")\r\n}\r\n\r\n// A triple represents a subject-predicate-object relationship with supporting evidence\r\nclass Triple {\r\n  subject Entity @description(\"The subject entity with full metadata and attributes\")\r\n  predicate string @description(\"The relationship/predicate connecting subject and object\")\r\n  object Entity @description(\"The object entity with full metadata and attributes\")\r\n  source SourceMetadata @description(\"Metadata about the source of this triple\")\r\n  supporting_spans CharacterSpan[] @description(\"Character spans in the source text that support this triple\")\r\n  extraction_datetime string? @description(\"ISO 8601 datetime when this triple was extracted (set automatically in post-processing)\")\r\n}\r\n\r\n// Defines a type of entity that can appear in the knowledge graph\r\nclass EntityType {\r\n  name string @description(\"The name of the entity type (e.g., 'Person', 'Organization', 'Campaign')\")\r\n  description string @description(\"A description of what this entity type represents\")\r\n  attributes AttributeDefinition[] @description(\"List of custom attributes that should be extracted for entities of this type\")\r\n}\r\n\r\n// Defines a type of relationship between entities\r\nclass RelationType {\r\n  name string @description(\"The name of the relation type (e.g., 'works_at', 'located_in')\")\r\n  description string @description(\"A description of what this relation represents\")\r\n  domain string @description(\"The entity type that can be the subject of this relation\")\r\n  range string @description(\"The entity type that can be the object of this relation\")\r\n}\r\n\r\n// An ontology defines the structure of the knowledge graph\r\nclass Ontology {\r\n  entity_types EntityType[] @description(\"List of valid entity types\")\r\n  relation_types RelationType[] @description(\"List of valid relation types\")\r\n}\r\n\r\n// The result of triple extraction\r\nclass ExtractionResult {\r\n  triples Triple[] @description(\"List of extracted triples from the text\")\r\n  reasoning string @description(\"Explanation of the extraction decisions and entity consistency choices\")\r\n}\r\n\r\n// Result of ontology recommendation\r\nclass OntologyRecommendation {\r\n  ontology Ontology @description(\"The recommended ontology with entity and relation types\")\r\n  text_purpose string @description(\"Analysis of the text's overarching purpose or goal\")\r\n  reasoning string @description(\"Explanation of why these entity and relation types were recommended\")\r\n}\r\n\r\n// Result of ontology extension analysis\r\nclass OntologyExtension {\r\n  needs_extension bool @description(\"Whether the ontology needs to be extended for this text\")\r\n  new_entity_types EntityType[] @description(\"New entity types to add (empty if none needed)\")\r\n  new_relation_types RelationType[] @description(\"New relation types to add (empty if none needed)\")\r\n  critical_information_at_risk string? @description(\"Description of what critical information would be lost without extension (null if needs_extension is false)\")\r\n  reasoning string @description(\"Detailed explanation of why extension is or isn't needed\")\r\n}\r\n\r\n// Main function to extract knowledge graph triples from text\r\nfunction ExtractTriples(\r\n  text: string,\r\n  ontology: Ontology,\r\n  source_metadata: SourceMetadata,\r\n  existing_triples: Triple[]\r\n) -> ExtractionResult {\r\n  client CustomFast\r\n  prompt #\"\r\n    You are a knowledge graph extraction expert. Your task is to extract structured triples (subject-predicate-object) from the provided text, with rich entity metadata, custom attributes, and supporting evidence.\r\n\r\n    {{ _.role(\"user\") }}\r\n    \r\n    ONTOLOGY:\r\n    You must extract triples that conform to the following ontology:\r\n    \r\n    Valid Entity Types:\r\n    {% for entity_type in ontology.entity_types %}\r\n    - {{ entity_type.name }}: {{ entity_type.description }}\r\n      {% if entity_type.attributes|length > 0 %}\r\n      Custom Attributes:\r\n      {% for attr in entity_type.attributes %}\r\n        * {{ attr.name }} ({{ attr.type }}): {{ attr.description }}\r\n      {% endfor %}\r\n      {% endif %}\r\n    {% endfor %}\r\n    \r\n    Valid Relation Types:\r\n    {% for relation_type in ontology.relation_types %}\r\n    - {{ relation_type.name }}: {{ relation_type.description }}\r\n      (Domain: {{ relation_type.domain }}, Range: {{ relation_type.range }})\r\n    {% endfor %}\r\n    \r\n    SOURCE METADATA:\r\n    Source Name: {{ source_metadata.source_name }}\r\n    {% if source_metadata.source_url %}\r\n    Source URL: {{ source_metadata.source_url }}\r\n    {% endif %}\r\n    \r\n    EXISTING TRIPLES:\r\n    {% if existing_triples|length > 0 %}\r\n    The following triples have already been extracted from OTHER sources. You MUST:\r\n    1. Use consistent entity names - if an entity appears in existing triples, use the EXACT same name\r\n    2. Maintain entity identity - recognize when entities in the new text are the same as entities in existing triples\r\n    3. Duplicate triples ARE ALLOWED if they come from different sources (different source names)\r\n    4. If you extract the same fact that exists in existing triples, it's okay as long as it's from this new source\r\n    \r\n    {% for triple in existing_triples %}\r\n    - {{ triple.subject.name }} ({{ triple.subject.type }}) -> {{ triple.predicate }} -> {{ triple.object.name }} ({{ triple.object.type }}) [from: {{ triple.source.source_name }}]\r\n    {% endfor %}\r\n    {% else %}\r\n    This is the first extraction, so there are no existing triples to consider.\r\n    {% endif %}\r\n    \r\n    TEXT TO ANALYZE:\r\n    {{ text }}\r\n    \r\n    ENTITY EXTRACTION INSTRUCTIONS:\r\n    \r\n    For each entity in a triple (both subject and object), you MUST provide:\r\n    \r\n    1. **name**: The entity's name or identifier from the text\r\n       - Use clear, consistent names (e.g., \"John Smith\" not \"John\" or \"Smith\")\r\n       - If the entity appears in existing triples, use the EXACT same name\r\n    \r\n    2. **type**: The entity type from the ontology\r\n       - Must match exactly one of the EntityType names defined above\r\n       - Check domain/range constraints in relation types\r\n    \r\n    3. **description**: A brief description of the entity\r\n       - Generate this from the text context (1-2 sentences)\r\n       - Include relevant details that help identify or characterize the entity\r\n       - Be concise but informative\r\n    \r\n    4. **custom_atts**: Extract ALL attributes defined for this entity type\r\n       - Format: {\"attribute_name\": {\"value\": \"extracted_value\", \"type\": \"attribute_type\"}}\r\n       - Set \"value\" to null if the attribute is not mentioned in the text\r\n       - \"type\" must match the type from the AttributeDefinition\r\n       - Extract dates in ISO format (YYYY-MM-DD) when possible\r\n       - For nested objects, use JSON string representation\r\n    \r\n    TRIPLE EXTRACTION INSTRUCTIONS:\r\n    \r\n    1. Extract all meaningful triples from the text that conform to the ontology\r\n    2. Only use entity types and relation types defined in the ontology\r\n    3. For each triple, identify TEXT SPANS that provide evidence:\r\n       - Copy the EXACT text from the source that supports the triple\r\n       - You can include multiple text spans if evidence is spread across different parts\r\n       - Be precise - copy text exactly as it appears, including punctuation and spacing\r\n       - Include enough context to make the evidence clear\r\n    4. Provide reasoning explaining your extraction decisions\r\n    \r\n    EXAMPLE:\r\n    \r\n    Text: \"The Check Your A1C campaign launched on August 10, 2025, targeting diabetic members to remind them to get their A1C checked.\"\r\n    \r\n    Ontology has EntityType \"Campaign\" with attributes:\r\n    - campaign_launch_dt (date): Launch date\r\n    - campaign_completion_dt (date): Completion date\r\n    \r\n    Extracted entity for subject:\r\n    {\r\n      \"name\": \"Check Your A1C campaign\",\r\n      \"type\": \"Campaign\",\r\n      \"description\": \"A campaign targeting diabetic members to remind them to get their A1C checked\",\r\n      \"custom_atts\": {\r\n        \"campaign_launch_dt\": {\"value\": \"2025-08-10\", \"type\": \"date\"},\r\n        \"campaign_completion_dt\": {\"value\": null, \"type\": \"date\"}\r\n      }\r\n    }\r\n    \r\n    Note: Character indices for supporting spans will be computed automatically in post-processing.\r\n    \r\n    {{ ctx.output_format }}\r\n  \"#\r\n}\r\n\r\n// Function to recommend an ontology based on text analysis\r\nfunction RecommendOntology(\r\n  text: string,\r\n  scope: string\r\n) -> OntologyRecommendation {\r\n  client CustomFast\r\n  prompt #\"\r\n    You are a knowledge graph ontology design expert. Your task is to analyze the provided text, understand its overarching purpose and domain, and recommend an appropriate ontology (entity types and relation types) that would be suitable for extracting knowledge from this and similar texts.\r\n\r\n    {{ _.role(\"user\") }}\r\n    \r\n    TEXT TO ANALYZE:\r\n    {{ text }}\r\n    \r\n    ONTOLOGY SCOPE: {{ scope }}\r\n    \r\n    GRANULARITY GUIDELINES:\r\n    \r\n    Your goal is to design an ontology with {{ scope }} scope. Use these principles to guide your decisions about how many types to create and how granular to make them.\r\n    \r\n    ENTITY TYPE GRANULARITY PRINCIPLES:\r\n    \r\n    1. **Abstraction Level**: Choose the right level of abstraction\r\n       - Too broad: \"Thing\", \"Entity\" (not useful)\r\n       - Too narrow: \"SoftwareEngineerAtGoogle\", \"CEOOfTechStartup\" (overfitting)\r\n       - Just right: \"Person\", \"Organization\", \"JobRole\" (reusable across instances)\r\n    \r\n    2. **Domain Relevance**: Include entity types that are central to THIS domain\r\n       - For medical text: Patient, Medication, Condition, Procedure, Hospital\r\n       - For business text: Company, Person, Investment, Product, Market\r\n       - Don't include types that rarely appear or aren't relevant to this specific text\r\n    \r\n    3. **Distinctiveness Test**: Only create separate types if they have:\r\n       - Different attributes or characteristics\r\n       - Different relationship patterns\r\n       - Different analytical value\r\n       - Example: \"Professor\" and \"Student\" are distinct if their relationships differ\r\n       - Example: \"CEO\" and \"CTO\" might both be \"ExecutiveRole\" if relationships are similar\r\n    \r\n    4. **Generalization**: Combine similar concepts under broader types when appropriate\r\n       - Instead of: \"Dog\", \"Cat\", \"Bird\" → use \"Animal\" (if distinctions don't matter)\r\n       - Instead of: \"Laptop\", \"Desktop\", \"Tablet\" → use \"Device\" or \"Computer\"\r\n       - BUT: Keep separate if the distinction is analytically important for this domain\r\n    \r\n    5. **Coverage**: Ensure types cover the main concepts in the text\r\n       - Don't create types for concepts that appear only once\r\n       - DO create types for recurring or structurally important concepts\r\n       - Focus on concepts that are central to understanding this domain\r\n    \r\n    RELATION TYPE GRANULARITY PRINCIPLES:\r\n    \r\n    1. **Semantic Precision**: Relations should capture meaningful distinctions\r\n       - Too vague: \"related_to\", \"associated_with\" (not informative)\r\n       - Too specific: \"works_at_as_senior_engineer_since_2020\" (overfitting)\r\n       - Just right: \"works_at\", \"employed_by\", \"manages\" (clear semantics)\r\n    \r\n    2. **Directionality Matters**: Choose direction that reflects real-world semantics\r\n       - \"Person works_at Organization\" (natural)\r\n       - Not \"Organization employs Person\" (unless that's the focus)\r\n       - Be consistent in your directional choices\r\n    \r\n    3. **Relationship Patterns**: Include relations that appear or could appear multiple times\r\n       - Medical: \"treats\", \"prescribes\", \"diagnoses\", \"hospitalized_at\"\r\n       - Business: \"invests_in\", \"founded\", \"acquired_by\", \"partners_with\"\r\n       - Focus on the relationships that matter for this domain\r\n    \r\n    4. **Avoid Redundancy**: Don't create near-synonyms unless there's semantic distinction\r\n       - Don't have both \"works_at\" and \"employed_by\" (pick one)\r\n       - Don't have both \"located_in\" and \"based_in\" (pick one)\r\n       - DO have \"founded\" and \"acquired\" (different events with different meanings)\r\n    \r\n    5. **Completeness**: Capture the key relationship types in the domain\r\n       - Think: \"What questions would someone ask about this data?\"\r\n       - Include relations that support those analytical questions\r\n       - Every relation should serve a clear analytical purpose\r\n    \r\n    SCOPE-SPECIFIC GUIDANCE:\r\n    \r\n    **If scope is \"minimal\":**\r\n    - Create only the most essential entity types (core concepts only)\r\n    - Focus on the most frequent and important relationships\r\n    - Err on the side of broader categories that combine similar concepts\r\n    - Typical result: 3-8 entity types, 4-10 relation types\r\n    - Use case: Quick extraction, simple queries, identifying broad patterns\r\n    - Example: For a business article → Person, Organization, Location, works_at, located_in\r\n    \r\n    **If scope is \"balanced\":**\r\n    - Include entity types for all significant concepts in the domain\r\n    - Capture the main relationship patterns without over-specifying\r\n    - Balance specificity with reusability across similar texts\r\n    - Typical result: 6-12 entity types, 8-15 relation types\r\n    - Use case: Standard analysis, general-purpose extraction, most common scenarios\r\n    - Example: For a business article → Person, Organization, Location, Product, Investment, works_at, located_in, founded, invests_in, develops\r\n    \r\n    **If scope is \"comprehensive\":**\r\n    - Include entity types for all distinct and meaningful concepts\r\n    - Capture nuanced relationship types that reflect domain expertise\r\n    - Allow for more domain-specific and specialized types\r\n    - Typical result: 10-20 entity types, 12-25 relation types\r\n    - Use case: Detailed analysis, domain expertise, research, specialized queries\r\n    - Example: For a business article → Person, Organization, Location, Product, Investment, Technology, Market, Role, works_at, located_in, founded, invests_in, develops, competes_with, targets, acquired_by, partners_with\r\n    \r\n    QUALITY OVER QUANTITY:\r\n    - It's better to have fewer, well-defined types than many poorly-defined ones\r\n    - Each type should have a clear, distinct purpose and detailed description\r\n    - Each type should be distinguishable from others in meaningful ways\r\n    - Every type you create should be useful for analysis and querying\r\n    - The numbers above are guidelines, not requirements - use your judgment\r\n    \r\n    SELF-CHECK QUESTIONS:\r\n    Before finalizing your ontology, ask yourself:\r\n    1. Can I clearly explain when to use each entity type vs. others?\r\n    2. Would two different people classify entities consistently with these types?\r\n    3. Are my relation types capturing distinct semantic relationships?\r\n    4. Can I extract useful, actionable information with this ontology?\r\n    5. Is this ontology reusable for similar texts in this domain?\r\n    6. Does the granularity match the requested scope level?\r\n    \r\n    ONTOLOGY DESIGN PRINCIPLES:\r\n    - Entity types should be nouns representing concrete or abstract concepts\r\n    - Relation types should be verbs or verb phrases that connect entities\r\n    - Each relation type must specify its domain (subject entity type) and range (object entity type)\r\n    - Prefer commonly understood terms over jargon unless domain-specific terms are essential\r\n    - Think about what would be useful for querying and analyzing this type of text\r\n    - Ensure descriptions are clear and detailed enough for accurate extraction\r\n    \r\n    CUSTOM ATTRIBUTES FOR ENTITY TYPES:\r\n    \r\n    For each entity type, you should define custom attributes that capture type-specific information:\r\n    \r\n    1. **Identify Key Attributes**: What information is important for this entity type?\r\n       - For Person: birth_date, nationality, occupation\r\n       - For Organization: founded_date, headquarters_location, industry\r\n       - For Campaign: launch_date, end_date, budget, target_audience\r\n       - For Product: release_date, version, price\r\n    \r\n    2. **Attribute Types**: Use appropriate data types\r\n       - \"string\": General text (names, descriptions, IDs)\r\n       - \"int\": Whole numbers (counts, quantities, years)\r\n       - \"float\": Decimal numbers (prices, percentages, measurements)\r\n       - \"bool\": True/false values (is_active, is_public)\r\n       - \"date\": ISO dates (YYYY-MM-DD format)\r\n       - Nested objects: For complex structured data (use JSON schema description)\r\n    \r\n    3. **Domain-Relevant Attributes**: Focus on what matters for this domain\r\n       - Medical domain: diagnosis_date, treatment_status, dosage\r\n       - Business domain: funding_amount, employee_count, revenue\r\n       - Academic domain: publication_date, citation_count, affiliation\r\n    \r\n    4. **Extraction-Friendly**: Choose attributes that can be extracted from text\r\n       - Prefer attributes commonly mentioned in text\r\n       - Avoid attributes requiring external knowledge\r\n       - Balance detail with extractability\r\n    \r\n    5. **Scope Considerations**:\r\n       - Minimal scope: 0-2 attributes per entity type (only essential ones)\r\n       - Balanced scope: 2-4 attributes per entity type (common, useful attributes)\r\n       - Comprehensive scope: 4-8 attributes per entity type (detailed characterization)\r\n    \r\n    EXAMPLE ENTITY TYPE WITH ATTRIBUTES:\r\n    \r\n    ```\r\n    EntityType: Campaign\r\n    Description: A marketing or outreach campaign\r\n    Attributes:\r\n      - name: campaign_launch_dt\r\n        type: date\r\n        description: The date when the campaign was launched\r\n      - name: campaign_completion_dt\r\n        type: date\r\n        description: The date when the campaign ended or is planned to end\r\n      - name: target_audience\r\n        type: string\r\n        description: The intended audience or demographic for the campaign\r\n      - name: campaign_budget\r\n        type: float\r\n        description: The budget allocated for the campaign in dollars\r\n    ```\r\n    \r\n    Your task is to analyze THIS specific text and recommend the most appropriate ontology for it,\r\n    following the principles above and designing for the requested \"{{ scope }}\" scope level.\r\n    Include appropriate custom attributes for each entity type based on the domain and text content.\r\n    \r\n    {{ ctx.output_format }}\r\n  \"#\r\n}\r\n\r\n// Function to analyze if an existing ontology needs extension for new text\r\nfunction AnalyzeOntologyExtension(\r\n  text: string,\r\n  current_ontology: Ontology,\r\n  scope: string\r\n) -> OntologyExtension {\r\n  client CustomFast\r\n  prompt #\"\r\n    You are a knowledge graph ontology expert. Your task is to analyze whether an existing ontology needs to be extended to properly extract knowledge from new text.\r\n    \r\n    {{ _.role(\"user\") }}\r\n    \r\n    CURRENT ONTOLOGY:\r\n    \r\n    Current Entity Types:\r\n    {% for entity_type in current_ontology.entity_types %}\r\n    - {{ entity_type.name }}: {{ entity_type.description }}\r\n      {% if entity_type.attributes|length > 0 %}\r\n      Attributes:\r\n      {% for attr in entity_type.attributes %}\r\n        * {{ attr.name }} ({{ attr.type }}): {{ attr.description }}\r\n      {% endfor %}\r\n      {% endif %}\r\n    {% endfor %}\r\n    \r\n    Current Relation Types:\r\n    {% for relation_type in current_ontology.relation_types %}\r\n    - {{ relation_type.name }}: {{ relation_type.description }}\r\n      (Domain: {{ relation_type.domain }}, Range: {{ relation_type.range }})\r\n    {% endfor %}\r\n    \r\n    NEW TEXT TO ANALYZE:\r\n    {{ text }}\r\n    \r\n    ONTOLOGY SCOPE: {{ scope }}\r\n    \r\n    YOUR TASK:\r\n    \r\n    Analyze whether the current ontology is sufficient to extract critical information from this new text,\r\n    or whether it needs to be conservatively extended.\r\n    \r\n    CONSERVATIVE EXTENSION PRINCIPLES:\r\n    \r\n    1. **Default to NO Extension**\r\n       - Start with the assumption that the existing ontology is sufficient\r\n       - Only recommend extension if absolutely necessary\r\n       - Prefer using existing types creatively over adding new ones\r\n    \r\n    2. **Critical Information Test**\r\n       - Extension is ONLY justified if failing to extend would result in losing CRITICAL information\r\n       - Ask: \"Can the essential facts be captured with existing types?\"\r\n       - If yes → No extension needed\r\n       - If no → Consider extension\r\n    \r\n    3. **Definition of Critical Information**\r\n       Critical information is information that:\r\n       - Is central to understanding the text's main points\r\n       - Cannot be reasonably represented with existing entity/relation types\r\n       - Would create significant semantic loss if omitted or forced into existing types\r\n       - Is not a minor detail or edge case\r\n    \r\n    4. **Examples of When Extension IS Needed**\r\n       - New text discusses \"Chemical Compounds\" but ontology only has \"Substance\"\r\n         → If chemical-specific relationships matter, extend\r\n       - New text has \"Software\" entities but ontology only has \"Product\"\r\n         → If software-specific attributes/relations are critical, extend\r\n       - New text introduces entirely new domain (e.g., legal domain in a medical ontology)\r\n         → If domain is central to the text, extend\r\n    \r\n    5. **Examples of When Extension is NOT Needed**\r\n       - New text mentions \"tablets\" but ontology has \"Device\" → Use Device\r\n       - New text has \"acquired_by\" but ontology has \"purchased_by\" → Use existing similar relation\r\n       - New text mentions a rare entity type appearing once → Don't extend for one-offs\r\n       - Differences are purely syntactic (naming) not semantic → Don't extend\r\n    \r\n    6. **Backward Compatibility**\r\n       Any new types you recommend must:\r\n       - Be distinct from existing types (not redundant or overlapping)\r\n       - Follow the same naming and description conventions\r\n       - Work alongside existing types without conflicts\r\n       - Be at the appropriate granularity level for the scope\r\n    \r\n    7. **Scope Awareness**\r\n       Consider the current scope ({{ scope }}):\r\n       - For \"minimal\" scope: Be VERY conservative, only extend for major gaps\r\n       - For \"balanced\" scope: Extend if missing significant concepts\r\n       - For \"comprehensive\" scope: More willing to add nuanced types\r\n    \r\n    ANALYSIS PROCESS:\r\n    \r\n    Step 1: Identify concepts in the new text\r\n    Step 2: For each concept, try to map it to existing entity types\r\n    Step 3: For each relationship, try to map it to existing relation types\r\n    Step 4: Identify any critical information that CANNOT be captured\r\n    Step 5: If critical gaps exist, propose minimal extensions\r\n    Step 6: Justify why each extension is necessary\r\n    \r\n    DECISION CRITERIA:\r\n    \r\n    Set needs_extension = true ONLY if:\r\n    ✓ There are concepts in the text that are critically important\r\n    ✓ These concepts cannot be reasonably mapped to existing types\r\n    ✓ Omitting them would cause significant information loss\r\n    ✓ The extensions align with the current scope level\r\n    \r\n    Set needs_extension = false if:\r\n    ✓ All critical information can be captured with existing types\r\n    ✓ Minor details might be lost but core facts are preserved\r\n    ✓ Existing types can be used flexibly to cover new concepts\r\n    \r\n    OUTPUT REQUIREMENTS:\r\n    \r\n    - If needs_extension = false:\r\n      * Set new_entity_types and new_relation_types to empty arrays\r\n      * Set critical_information_at_risk to null (no critical information is at risk)\r\n      * Explain in reasoning how existing types cover the text\r\n      * Be specific about which existing types map to which concepts\r\n    \r\n    - If needs_extension = true:\r\n      * Provide ONLY the new types needed (don't repeat existing ones)\r\n      * Describe in critical_information_at_risk what critical information would be lost without extension\r\n      * Explain in reasoning why each new type is essential\r\n      * Keep extensions minimal - only add what's absolutely necessary\r\n    \r\n    QUALITY CHECKS:\r\n    \r\n    Before recommending extension, verify:\r\n    1. Can I extract the main facts with existing types? (If yes → no extension)\r\n    2. Is the \"missing\" information truly critical? (If no → no extension)\r\n    3. Are my new types distinct from existing ones? (If not → no extension)\r\n    4. Am I being conservative? (If not → reconsider)\r\n    \r\n    Remember: It's better to slightly stretch existing types than to proliferate unnecessary new types.\r\n    The ontology should evolve slowly and deliberately, not expand with every new text.\r\n    \r\n    {{ ctx.output_format }}\r\n  \"#\r\n}\r\n\r\n",
}

def get_baml_files():
    return _file_map